package leetcode;

/**
 * 94 全消子序列的最大长度
 *
 * 一个子序列的消除规则如下:
 * 1)在某一个子序列中,如果 '1' 的左边有' 0' ,那么这两个字符->"01" 可以消除
 * 2)在某一个子序列中,如果3的左边有2,那么这两个字符>23可以消除
 * 3)当这个子序列的某个部分消除之后,认为其他字符会自动贴在一起,可以继续寻找消除的机会
 *
 * 比如,某个子序列"0231",先消除掉"23",那么剩下的字符贴在一起变成"01",继续消除就没有字符了
 * 如果某个子序列通过最优良的方式,可以都消掉,那么这样的子序列叫做“全消子序列”
 *  一个只由0、1、2、3四种字符组成的字符串str,可以生成很多子序列,返回“全消子序列”的最大长度
 * 字符串str长度<=200
 */
public class Code94_0123Disappear {

    public int find(char[] str, int l, int r) {
        if (l >= r) {
            return 0;
        }
        if (l == r - 1) {
            return (str[l] == '0' && str[r] == '1') || (str[l] == '2' && str[r] == '3') ? 2 : 0;
        }
        // 不包括l位置
        int p1 = find(str, l + 1, r);
        if (str[l] == '1' || str[l] == '3') {
            return p1;
        }
        // 考虑包括l位置
        int p2 = 0;
        char find = str[l] == '0' ? '1' : '3';
        for (int i = l + 1; i <= r; i++) {
            //l(0)....i(1) i+1....r
            // l和i位置消除
            if (str[i] == find) {
                p2 = Math.max(p2, find(str, l + 1, i - 1) + 2 + find(str, i + 1, r));
            }
        }
        return Math.max(p1, p2);
    }
}
